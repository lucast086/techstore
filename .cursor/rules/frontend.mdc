---
description: 
globs: 
alwaysApply: false
---
# Frontend Development Rules

## ANGULAR BEST PRACTICES

Always write clean, maintainable code following Angular best practices:

### ARCHITECTURE & ORGANIZATION
- Use TypeScript interfaces and models for strong typing
- Create reusable services with proper dependency injection
- Implement lazy loading for all feature modules
- Create meaningful component hierarchies with smart/presentational pattern
- Organize imports semantically

### STYLING & LAYOUT
- Implement responsive layouts with PrimeFlex (use pfx- prefix) grid system
- Use flex layout classes instead of custom CSS when possible
- Use PrimeIcons with the recommended syntax (pi pi-icon-name)

### COMPONENTS & SERVICES
- Follow PrimeNG component patterns
- Utilize built-in validation mechanisms
- Use OnPush change detection when possible
- Prefer RxJS observables for state management

### CODE QUALITY
- Apply strict typing to all variables, parameters and return values
- Avoid using 'any' type
- Document code with JSDoc comments
- Follow Angular style guide for naming conventions
- Prefer async/await over raw promises
- Implement proper error handling in HTTP services

### PERFORMANCE
- Avoid unnecessary component re-renders
- Use trackBy with ngFor directives
- Unsubscribe from observables to prevent memory leaks
- Use lazy loading for heavy components

## TECHNICAL IMPLEMENTATION

### Component Structure
```typescript
@Component({
  selector: 'app-feature',
  templateUrl: './feature.component.html',
  styleUrls: ['./feature.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class FeatureComponent implements OnInit, OnDestroy {
  // Strong typing for all properties
  items: Item[] = [];
  loading = false;
  
  // Private subjects for managing component state
  private destroy$ = new Subject<void>();
  
  constructor(private featureService: FeatureService) {}
  
  ngOnInit(): void {
    this.loadData();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  // Use async/await pattern
  async loadData(): Promise<void> {
    try {
      this.loading = true;
      this.items = await this.featureService.getItems()
        .pipe(takeUntil(this.destroy$))
        .toPromise();
    } catch (error) {
      // Proper error handling
      console.error('Failed to load items', error);
    } finally {
      this.loading = false;
    }
  }
}